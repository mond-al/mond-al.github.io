<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="https://mond-al.github.io/tag/r/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://mond-al.github.io/" rel="alternate" type="text/html" />
  <updated>2021-02-06T02:27:32+09:00</updated>
  <id>https://mond-al.github.io/tag/r/feed.xml</id>

  
  
  

  
    <title type="html">Developer/App/Android/mond &amp;gt; Log | </title>
  

  
    <subtitle>안드로이드 개발 로깅.</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">안드로이드 targetSdkVersion 30으로 올리기(Scoped Storage)</title>
      <link href="https://mond-al.github.io/2021/02/01/android-11-R.html" rel="alternate" type="text/html" title="안드로이드 targetSdkVersion 30으로 올리기(Scoped Storage)" />
      <published>2021-02-01T00:00:00+09:00</published>
      <updated>2021-02-01T00:00:00+09:00</updated>
      <id>https://mond-al.github.io/2021/02/01/android-11-R</id>
      <content type="html" xml:base="https://mond-al.github.io/2021/02/01/android-11-R.html">Android 11(R)은 Android 6.0(M,Marshmallow)이후로 가장 큰 변화가 생긴 버전이 아닐까 합니다.

## Scoped Storage 적용

Android 10(Q) 발표당시 안드로이드 개발자를 공포로 몰아넣었던 `Scoped Storage`의 유예기간이 종료되었습니다. targetSdkVersion 29를 적용할때 `Scoped Storage`를 무시할 수 있도록 제공된 `requestLegacyExternalStorage`는 targetSdkVersion 30이 적용되면 Android 11(R) 이상 디바이스에서 무시됩니다. [&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;](https://developer.android.com/about/versions/11/privacy/storage?hl=ko#scoped-storage)

대신 또 다른 일회성 유예가 추가되었습니다. `preserveLegacyExternalStorage`라는 플래그입니다. 이 플래그를 적용하면, `기존`에 사용하던 파일을 이전 할 수 있도록 예외처리됩니다. 하지만 첫 설치 또는 앱 삭제후 재설치한 경우에는 예외가 적용되지 않습니다.[&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;](https://developer.android.com/training/data-storage/use-cases?hl=ko#if_your_app_targets)

Android 9(O,Oreo)이전까지 개발자들은 `&quot;WRITE_EXTERNAL_STORAGE&quot;`권한 하나만 얻으면 뭐든 할 수 있었습니다. external storage의 루트에 자기앱이름을 따서 폴더를 만들어서 갤러리에 보여줄 파일을 다운받거나 생성하기도 하고, 그 하위나 또 다른 은밀한?곳에 `&quot;.&quot;(dot)`으로 시작하는 폴더와 `&quot;.nomedia&quot;`파일을 이용해서 사용자 몰래 앱이 지워져도 사라지지 않을 부스러기를 생성할 수 있었죠.
 

### targetSdkVersion 30 을 적용하는 순간 `WRITE_EXTERNAL_STORAGE`는 완전히 무시됩니다.[&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;](https://developer.android.com/about/versions/11/privacy/storage?hl=ko#permissions-target-11)

지금까지는 `WRITE_EXTERNAL_STORAGE`을 요청하고 승인받으면, 자동으로 `READ_EXTERNAL_STORAGE`를 획득 할 수 있었기 때문에 `READ_EXTERNAL_STORAGE`를 암묵적으로 따로 처리 하지 않은 경우를 많이 찾아 볼 수 있었습니다. 이런 경우 `onRequestPermissionsResult`에서 `WRITE_EXTERNAL_STORAGE`는 항상 `PERMISSION_DENIED`이기 때문에, 다시 권한을 사용자에게 요청하는 교착상태에 빠질 수 있습니다. 

&gt; 솔루션 : 앱 외부공간에 파일을 쓸 일이 있다면, 안드로이드 Q미만에서는 `WRITE_EXTERNAL_STORAGE`,`READ_EXTERNAL_STORAGE`를 사용하고 Q이상에서는 `READ_EXTERNAL_STORAGE`만 요청하도록 분기해야 합니다.

&gt; 솔루션 : `requestLegacyExternalStorage`를 적용하면 Android 10 디바이스에서 `WRITE_EXTERNAL_STORAGE`를 계속 사용 할 수 있지만 `maxSdkVersion=&quot;28&quot;`을 명시하여 Q미만과 Q이상으로 구분하는 것이 좋을 것 같습니다. 결국은 사용자의 환경은 Android 11로 넘어 갈 것이고 `Scoped Storage`대응을 미루어야 할 이유는 없습니다. 
```xml
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; 
                     android:maxSdkVersion=&quot;28&quot; /&gt;
```

매번 이야기 하기가 번거롭기 때문에 용어를 정리하겠습니다. `Scoped Storage 적용된 상태`라는 말은 targetSdkVersion 29에서 requestLegacyExternalStorage를 사용하지 않았거나 targetSdkVersion 30을 적용한 앱을 Android 10 단말에서 사용하는 상태를 말합니다.

### 파일 생성과 쓰기 방법이 변경 되었습니다.

예를 들어 아래처럼 메모리카드 루트폴더에 폴더를 생성하고 파일쓰기가 가능했지만, 이제 WRITE_EXTERNAL_STORAGE가 허용되지 않으니 Scoped Storage가 적용 된 상태라면 아래의 코드는 파일을 생성 할 수 없습니다. 아마도 `open failed: ENOENT (No such file or directory)` 같은 에러가 발생할 것 입니다.
```kotlin
val path = Environment.getExternalStorageDirectory().getAbsolutePath()+&quot;/tmp&quot;
        ....
File(path,filename) // case #1
        
```
대신 앱 영역(apps' private directories)에 파일을 생성하는데 제한은 없습니다. 
```kotlin
val path = context.getDir(&quot;tmp&quot;, Context.MODE_PRIVATE).getPath()
        ....
File(path,filename) // case #2
        
```

`Scoped Storage 적용되지 않은 상태`에서는 새롭게 생성한 이미지나 미디어 파일을 사용자의 갤러리앱에 노출하기 위해서는 아래처럼 contentResolver에 파일을 등록하도록 하였습니다. 코드의 문맥을 보면 파일의 절대경로는 별도로 존재하고 미디어 DB에 해당 파일의 row를 추가하는 형태 였습니다.
```kotlin
val contentValues = ContentValues()
        ....
contentValues.put(MediaStore.Images.Media.DATA, file.absolutePath) 
contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues) // case #3  
```
`Scoped Storage 적용된 상태`에서 case #2의 형태로 생성한 파일생성하고, case #3의 코드로 미디어를 등록하면 되지않을까하고 한번 해보았지만, 원하는 형태가 되진 않았습니다. 분명 DB에 추가는 되었지만, 이미지 파일을 볼 수 없습니다.

![capture1](assets/images/post/2021-02-01-android-11-R/capture_failure_01.png)
![capture2](assets/images/post/2021-02-01-android-11-R/capture_failure_02.png)


`Scoped Storage 적용되지 않은 상태`</content>

      
      
      
      
      

      <author>
          <name>jisoo Yang</name>
        
        
      </author>

      

      
        <category term="android" />
      
        <category term="sdkversion30" />
      
        <category term="R" />
      

      
        <summary type="html">Android 11(R)은 Android 6.0(M,Marshmallow)이후로 가장 큰 변화가 생긴 버전이 아닐까 합니다.</summary>
      

      
      
    </entry>
  
</feed>
